class PriorityQueue{constructor(){this.items=[]}enqueue(t,i){var s={element:t,priority:i};let e=!1;for(let t=0;t<this.items.length;t++)if(s.priority<this.items[t].priority){this.items.splice(t,1,s),e=!0;break}e||this.items.push(s)}dequeue(){return this.items.shift()}isEmpty(){return 0===this.items.length}}class AStar{constructor(t){this.grid=t,this.openList=new PriorityQueue,this.closedList=[],this.startNode=null,this.endNode=null,this.path=[]}heuristic(t,i){return Math.abs(t.x-i.x)+Math.abs(t.y-i.y)}findNeighbors(t){var i,s=[];for(i of[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}]){var e=t.x+i.x,r=t.y+i.y;0<=e&&e<this.grid[0].length&&0<=r&&r<this.grid.length&&s.push(this.grid[r][e])}return s}findPath(t,i,s,e){for(this.startNode=this.grid[i][t],this.endNode=this.grid[e][s],this.openList.enqueue(this.startNode,0);!this.openList.isEmpty();){var r=this.openList.dequeue().element;if(r===this.endNode)return this.reconstructPath(r),this.path;this.closedList.push(r);for(let i of this.findNeighbors(r))if(!this.closedList.includes(i)&&!i.isWall){var h=r.g+1;let t=!1;this.openList.items.some(t=>t.element===i)?h<i.g&&(t=!0):(t=!0,i.h=this.heuristic(i,this.endNode),this.openList.enqueue(i,i.f)),t&&(i.g=h,i.f=i.g+i.h,i.previous=r)}}return[]}reconstructPath(t){for(;t.previous;)this.path.push(t),t=t.previous;this.path.reverse()}}let grid=[],rows=10,cols=10;for(let s=0;s<rows;s++){let i=[];for(let t=0;t<cols;t++)i.push({x:t,y:s,g:0,h:0,f:0,isWall:!1,previous:null});grid.push(i)}grid[4][2].isWall=!0,grid[4][3].isWall=!0,grid[4][4].isWall=!0,grid[4][5].isWall=!0,grid[4][6].isWall=!0;let astar=new AStar(grid),path=astar.findPath(0,0,9,9);console.log("Path found:");for(let t of path)console.log(`(${t.x}, ${t.y})`);